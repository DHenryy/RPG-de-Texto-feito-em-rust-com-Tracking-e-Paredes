use std::{io, thread, time::Duration, io::Write};
use rand::{Rng, seq::SliceRandom, thread_rng};
use colored::*;

// ################### FUNÇÕES AUXILIARES #################
// Função para simular digitação lenta
fn digita_baixo(text: &str, delay_ms: u64) {
    for c in text.chars() {
        print!("{}", c);
        io::stdout().flush().unwrap();
        thread::sleep(Duration::from_millis(delay_ms));
    }
    println!();
}

fn calcular_dano(dano_bruto: i32, resistencia: i32) -> i32 {
    let dano = dano_bruto - resistencia;
    if dano < 0 { 0 } else { dano }
}

fn mostrar_mapa(mapa: &Vec<Vec<Sala>>, px: usize, py: usize) {
    println!("{}", "\n=== MAPA DO CASTELO ===".bold().cyan());

    for y in 0..mapa.len() {
        for x in 0..mapa[y].len() {
            if x == px && y == py {
                print!("{}", " P ".on_bright_green().black());
            } else if mapa[y][x].visitada {
                print!("{}", " V ".on_bright_blue().black());
            } else {
                print!("{}", " ? ".on_bright_black());
            }
        }
        println!();
    }

    println!("{}", "P = você | V = visitada | ? = desconhecida\n".bold());
}

fn mover_inimigos(mapa: &mut Vec<Vec<Sala>>, px: usize, py: usize) {
    let tam = mapa.len();
    let mut rng = thread_rng();

    for y in 0..tam {
        for x in 0..tam {
            if let Some(_) = mapa[y][x].inimigo {
                let dx = if rng.gen_bool(0.5) { 1 } else { -1 };
                let dy = if rng.gen_bool(0.5) { 1 } else { -1 };

                let nx = ((x as isize + dx).max(0) as usize).min(tam - 1);
                let ny = ((y as isize + dy).max(0) as usize).min(tam - 1);

                if mapa[ny][nx].inimigo.is_none() && !(nx == px && ny == py) {
                    mapa[ny][nx].inimigo = mapa[y][x].inimigo.take();
                }
            }
        }
    }
}

// ####################### ENUMS ##############################

#[derive(Debug, Clone, Copy)]
enum Classes {
    Guerreiro,
    Mago,
    Arqueiro,
    Padre,
    Ladrão,
}

#[derive(Debug, Clone, Copy)]
enum Inimigos {
    Goblin,
    Zumbi,
    Esqueleto,
    CavaleiroAssombrado,
    Wyrm,
}

#[derive(Debug, Clone, Copy)]
enum Tesouro {
    PoçãoVida,
    PoçãoMana,
    XPExtra,
}

// #########################STRUCTS ########################

#[derive(Debug)]
struct Personagem {
    nome: String,
    classe: Classes,
    força: i32,
    res_fisica: i32,
    res_magica: i32,
    vida_atual: i32,
    vida_max: i32,
    mana_atual: i32,
    mana_max: i32,
    xp_atual: i32,
    xp_para_nivel: i32,
    nivel: i32,
}

#[derive(Debug)]
struct InimigoAtivo {
    tipo: Inimigos,
    vida_atual: i32,
    vida_max: i32,
    força: i32,
    res_fisica: i32,
    res_magica: i32,
    xp_dropado: i32,
}

#[derive(Debug)]
struct Sala {
    descricao: &'static str,
    inimigo: Option<Inimigos>,
    tesouro: Option<Tesouro>,
    visitada: bool,
    posicao_inimigo: Option<Posicao>,
}

#[derive(Debug, Clone, Copy)]
struct Posicao {
    x: usize,
    y: usize,
}

// ############################ IMPLEMENTAÇÕES ###############################

impl Classes {
    fn aleatoria() -> Self {
        let mut rng = thread_rng();
        let classes = [Classes::Guerreiro, Classes::Mago, Classes::Arqueiro, Classes::Padre, Classes::Ladrão];
        *classes.choose(&mut rng).unwrap()
    }
}

impl Personagem {
    fn new(nome: String, classe: Classes) -> Self {
        let (força, res_fisica, res_magica, vida_max, mana_max) = match classe {
            Classes::Guerreiro => (13, 10, 1, 100, 30),
            Classes::Mago => (5, 5, 13, 70, 100),
            Classes::Arqueiro => (10, 7, 8, 80, 30),
            Classes::Padre => (8, 10, 15, 80, 60),
            Classes::Ladrão => (8, 8, 8, 75, 40),
        };
        Self {
            nome,
            classe,
            força,
            res_fisica,
            res_magica,
            vida_atual: vida_max,
            vida_max,
            mana_atual: mana_max,
            mana_max,
            xp_atual: 0,
            xp_para_nivel: 100,
            nivel: 1,
        }
    }

    fn mostrar_status(&self) {
        println!("{}", "========= STATUS =========".bold().cyan());
        digita_baixo(&format!("{} {}", "Nome:".bold(), self.nome.bright_yellow()), 1);
        digita_baixo(&format!("{} {:?}", "Classe:".bold(), self.classe), 1);
        digita_baixo(&format!("{} {}", "Nível:".bold(), self.nivel.to_string().bright_green()), 1);
        digita_baixo(&format!("{} {}", "Força:".bold(), self.força.to_string().red()), 1);
        digita_baixo(&format!("{} {}", "Res Fís:".bold(), self.res_fisica.to_string().blue()), 1);
        digita_baixo(&format!("{} {}", "Res Mag:".bold(), self.res_magica.to_string().magenta()), 1);
        digita_baixo(&format!("{} {}/{}", "Vida:".bold(), self.vida_atual.to_string().green(), self.vida_max), 1);
        digita_baixo(&format!("{} {}/{}", "Mana:".bold(), self.mana_atual.to_string().cyan(), self.mana_max), 1);
        digita_baixo(&format!("{} {}/{}", "XP:".bold(), self.xp_atual.to_string().yellow(), self.xp_para_nivel), 1);
        println!("{}", "===========================".bold().cyan());
    }

    fn atacar(&self, inimigo: &mut InimigoAtivo, magico: bool) {
        let mut rng = rand::thread_rng();
        let dano_bruto = rng.gen_range((self.força - 1).max(0)..=self.força + 7);
        let dano_final = if magico { calcular_dano(dano_bruto, inimigo.res_magica) }
                          else { calcular_dano(dano_bruto, inimigo.res_fisica) };
        inimigo.vida_atual -= dano_final;
        let tipo_ataque = if magico { "mágico" } else { "físico" };
        digita_baixo(&format!("Você usa ataque {} e causa {} de dano!", tipo_ataque, dano_final), 30);
        inimigo.mostrar_status();
    }

    fn level_up(&mut self) {
        self.nivel += 1;
        self.força += 2;
        self.res_fisica += 1;
        self.res_magica += 1;
        self.vida_max += 10;
        self.mana_max += 5;
        self.vida_atual = self.vida_max;
        self.mana_atual = self.mana_max;
        digita_baixo(&format!("Parabéns! Você subiu para o nível {}!", self.nivel), 50);
        println!("{}", "Seus atributos aumentaram e você recuperou vida e mana!".green());
    }
}

impl Inimigos {
    fn aleatorio() -> Inimigos {
        let mut rng = thread_rng();
        let roll = rng.gen_range(0..100);
        if roll < 25 {
            Inimigos::Goblin
        } else if roll < 50 {
            Inimigos::Zumbi
        } else if roll < 70 {
            Inimigos::Esqueleto
        } else if roll < 91 {
            Inimigos::CavaleiroAssombrado
        } else {
            Inimigos::Wyrm
        }
    }
}

impl InimigoAtivo {
    fn novo(tipo: Inimigos) -> Self {
        match tipo {
            Inimigos::Goblin => Self { tipo, vida_atual: 30, vida_max: 30, força: 10, res_fisica: 5, res_magica: 3, xp_dropado: 10 },
            Inimigos::Zumbi => Self { tipo, vida_atual: 40, vida_max: 40, força: 5, res_fisica: 5, res_magica: 4, xp_dropado: 20 },
            Inimigos::Esqueleto => Self { tipo, vida_atual: 35, vida_max: 35, força: 10, res_fisica: 2, res_magica: 2, xp_dropado: 20 },
            Inimigos::CavaleiroAssombrado => Self { tipo, vida_atual: 50, vida_max: 50, força: 16, res_fisica: 5, res_magica: 2, xp_dropado: 40 },
            Inimigos::Wyrm => Self { tipo, vida_atual: 80, vida_max: 80, força: 20, res_fisica: 10, res_magica: 10, xp_dropado: 100 },
        }
    }

    fn atacar(&self, personagem: &mut Personagem, magico: bool) {
        let mut rng = thread_rng();
        let dano_bruto = rng.gen_range((self.força - 3).max(0)..=self.força + 6);
        let dano_final = if magico { calcular_dano(dano_bruto, personagem.res_magica) }
                          else { calcular_dano(dano_bruto, personagem.res_fisica) };
        personagem.vida_atual -= dano_final;
        let tipo_ataque = if magico { "mágico" } else { "físico" };
        digita_baixo(&format!("O {:?} usa ataque {} e causa {} de dano!", self.tipo, tipo_ataque, dano_final), 30);
        personagem.mostrar_status();
    }

    fn mostrar_status(&self) {
        println!("{}", "===== STATUS INIMIGO =====".bold().red());
        println!("Tipo: {:?}", self.tipo);
        println!("Vida: {}/{}", self.vida_atual, self.vida_max);
        println!("Força: {}", self.força);
        println!("Res Física: {}", self.res_fisica);
        println!("Res Mágica: {}", self.res_magica);
        println!("{}", "==========================".bold().red());
    }
}

// ######################### BATALHA ##########################

fn batalha(personagem: &mut Personagem, inimigo: &mut InimigoAtivo) -> bool {
    digita_baixo(&format!("Um {:?} apareceu!", inimigo.tipo), 30);

    loop {
        println!("\n=== Sua vez ===");
        println!("1. Ataque físico | 2. Ataque mágico | 3. Fugir");

        print!("Escolha: ");
        io::stdout().flush().unwrap();
        let mut escolha = String::new();
        io::stdin().read_line(&mut escolha).unwrap();
        match escolha.trim() {
            "1" => personagem.atacar(inimigo, false),
            "2" => {
                if personagem.mana_atual >= 10 {
                    personagem.atacar(inimigo, true);
                    personagem.mana_atual -= 10;
                } else {
                    println!("{}", "Mana insuficiente!".red());
                    continue;
                }
            }
            "3" => {
                if rand::thread_rng().gen_bool(0.5) {
                    println!("{}", "Você fugiu com sucesso!".yellow());
                    return false;
                } else {
                    println!("{}", "Falha ao fugir!".red());
                }
            }
            _ => { println!("Escolha inválida!"); continue; }
        }

        if inimigo.vida_atual <= 0 {
            println!("{}", format!("Você derrotou o {:?}!", inimigo.tipo).green());
            personagem.xp_atual += inimigo.xp_dropado;
            while personagem.xp_atual >= personagem.xp_para_nivel {
                personagem.xp_atual -= personagem.xp_para_nivel;
                personagem.xp_para_nivel += 50;
                personagem.level_up();
            }
            return true;
        }

        println!("\n=== Turno do inimigo ===");
        inimigo.atacar(personagem, false);
        if personagem.vida_atual <= 0 { return false; }
    }
}

// ################## LOOT ################

fn loot_tesouro(personagem: &mut Personagem, sala: &mut Sala) {
    if let Some(tesouro) = sala.tesouro {
        match tesouro {
            Tesouro::PoçãoVida => {
                personagem.vida_atual += 30;
                if personagem.vida_atual > personagem.vida_max {
                    personagem.vida_atual = personagem.vida_max;
                }
                digita_baixo("Você encontrou uma Poção de Vida!", 30);
            }
            Tesouro::PoçãoMana => {
                personagem.mana_atual += 20;
                if personagem.mana_atual > personagem.mana_max {
                    personagem.mana_atual = personagem.mana_max;
                }
                digita_baixo("Você encontrou uma Poção de Mana!", 30);
            }
            Tesouro::XPExtra => {
                personagem.xp_atual += 50;
                digita_baixo("Você ganhou 50 XP extra!", 30);
                while personagem.xp_atual >= personagem.xp_para_nivel {
                    personagem.xp_atual -= personagem.xp_para_nivel;
                    personagem.xp_para_nivel += 50;
                    personagem.level_up();
                }
            }
        }
        sala.tesouro = None;
    } else {
        digita_baixo("Não há baú nesta sala.", 30);
    }
}

// ############### EXPLORAÇÃO ##################

fn explorar_castelo(personagem: &mut Personagem) {
    let mut rng = thread_rng();
    const TAM: usize = 4;

    let mut mapa: Vec<Vec<Sala>> = (0..TAM).map(|_| {
        (0..TAM).map(|_| {
            let inimigo = if rng.gen_bool(0.5) { Some(Inimigos::aleatorio()) } else { None };
            let tesouro = if rng.gen_bool(0.25) {
                let item = match rng.gen_range(0..3) {
                    0 => Tesouro::PoçãoVida,
                    1 => Tesouro::PoçãoMana,
                    _ => Tesouro::XPExtra,
                };
                Some(item)
            } else { None };
            Sala {
                descricao: "Uma sala misteriosa...",
                inimigo,
                tesouro,
                visitada: false,
                posicao_inimigo: None,
            }
        }).collect()
    }).collect();

    let mut px = 0;
    let mut py = 0;

    loop {
    print!("{esc}[2J{esc}[H", esc = 27 as char);
    println!("{}", "=== EXPLORAÇÃO DO CASTELO ===".bold().cyan());

    // Marca a sala atual como visitada
    mapa[py][px].visitada = true;

    // Mostrar mapa
    mostrar_mapa(&mapa, px, py);

    // Mover inimigos (não conflita mais, pois não temos &mut sala ativo)
    mover_inimigos(&mut mapa, px, py);

    println!("Você está na sala ({},{})", px, py);

    // Inimigo na sala
    if let Some(inim) = mapa[py][px].inimigo {
        println!("Inimigo presente: {:?}", inim);
        let mut inimigo_ativo = InimigoAtivo::novo(inim);
        let venceu = batalha(personagem, &mut inimigo_ativo);
        if !venceu {
            println!("{}", "Você morreu!".red());
            continue;
        } else {
            mapa[py][px].inimigo = None;
        }
    }

    // Baú na sala
    if mapa[py][px].tesouro.is_some() {
        println!("Você vê um baú! (Use 'O' para abrir)");
    }

    println!("Movimentos possíveis: W/A/S/D | C para status | O para baú | Q para sair");
    print!("> ");
    io::stdout().flush().unwrap();

    let mut input = String::new();
    io::stdin().read_line(&mut input).unwrap();

    match input.trim().to_uppercase().as_str() {
        "W" if py > 0 => py -= 1,
        "S" if py < TAM - 1 => py += 1,
        "A" if px > 0 => px -= 1,
        "D" if px < TAM - 1 => px += 1,
        "C" => personagem.mostrar_status(),
        "O" => loot_tesouro(personagem, &mut mapa[py][px]),
        "Q" => { println!("Saindo..."); return; }
        _ => println!("Comando inválido!"),
    }
}
}

// ############# CRIAÇÃO DE PERSONAGEM ##############
fn criar_personagem() -> Personagem {
    digita_baixo("Bem-vindo ao RPG em Rust!", 30);
    digita_baixo("Escolha uma classe para seu personagem:", 30);
    digita_baixo("1. Guerreiro | 2. Mago | 3. Arqueiro | 4. Padre | 5. Ladrão | 0 Aleatório", 50);

    println!("Digite o número da classe desejada ou 0 para aleatório:");
    let mut input = String::new();
    io::stdin().read_line(&mut input).unwrap();
    let escolha: i32 = input.trim().parse().unwrap_or(0);

    let classe = match escolha {
        1 => Classes::Guerreiro,
        2 => Classes::Mago,
        3 => Classes::Arqueiro,
        4 => Classes::Padre,
        5 => Classes::Ladrão,
        _ => Classes::aleatoria(),
    };

    println!("Digite o nome do seu personagem:");
    let mut nome = String::new();
    io::stdin().read_line(&mut nome).unwrap();
    let nome = nome.trim().to_string();

    Personagem::new(nome, classe)
}

// ################# MAIN #####################

fn main() {
    let mut jogador = criar_personagem();
    explorar_castelo(&mut jogador);
}
